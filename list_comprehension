-module(list_comprehension).
-compile([export_all]).

discover_type(X) when is_integer(X) -> int;
discover_type(X) when is_float(X) -> f;
discover_type(X) -> str.

chosen_OPS(Ops) -> Num = random:uniform(length(Ops)), 
	Elem = lists:nth(random:uniform(length(Ops)),Ops),
	[Elem | chosen_OPS(Num,Ops)].
chosen_OPS(0,_) -> [];
chosen_OPS(Num,Ops) -> 	
[lists:nth(random:uniform(length(Ops)),Ops)| chosen_OPS(Num-1,Ops)].

chosen_COMP(Comps) -> lists:nth(random:uniform(length(Comps)),Comps).

do_OPS([]) ->  case random:uniform(2) of
		1 -> io:fwrite("~f ",[random:uniform()]);
		_ -> io:fwrite("~p ",[random:uniform(100000)])
	end;

do_OPS([H|T]) -> 
	case random:uniform(2) of
		1 -> io:fwrite("~f ~s ",[random:uniform(), H]);
		_ -> io:fwrite("~p ~s ",[random:uniform(100000), H])
	end,
	do_OPS(T).

generate() ->
	Operators = ["+" ,"*", "-", "/"], % div and rem removed because of floating numbers.
	Comparators = ["=:=", "=/=", "==", "/=", ">=", "=<", ">", "<"],
	%% chosen_OPS(Comparators) ++ chosen_OPS(Operators).
	%% COMPS = chosen_COMPS(Comparators),
	do_OPS(chosen_OPS(Operators)).

%% This method receives two parameters and it outputs a comparation between the two of them.

generate_Comparation(X,Y) ->
	Comparators = ["=:=", "=/=", "==", "/=", ">=", "=<", ">", "<"],
	Chosen_One = lists:nth(random:uniform(length(Comparators)),Comparators),
	io:fwrite("~s", ["("]),
	case discover_type(X) of
		int -> io:fwrite("~p ",[X]);
		f -> io:fwrite("~f ", [X]);
		_ -> io:fwrite("~s ",["X "])
	end,
	io:fwrite("~s ", [Chosen_One]),
	case discover_type(Y) of
		int -> io:fwrite("~p ",[Y]);
		f -> io:fwrite("~f ", [Y]);
		_ -> io:fwrite("~s ",[" Y"])
	end,
	io:fwrite("~s", [")"]).


generate2() ->
	Comparators = ["=:=", "=/=", "==", "/=", ">=", "=<", ">", "<"],
	do_OPS([chosen_COMP(Comparators)]).

% GENERATES VAR ASSIGNATIONS
generate3() -> 
	Variables = ["X","Y","Z","M","N","O","P","Q","R","S","T"],
	List = lists:sublist(Variables,random:uniform(10)),
	do_VARS(List).

do_VARS([]) -> io:fwrite("~s",[" "]);
do_VARS([H|T]) -> io:fwrite("~n ~s = ",[H]), 
				generate(),
				do_VARS(T).

% DATA TYPES: Tuple, Map, List, 
generate4() -> 
	case random:uniform(2) of
		1 ->  io:fwrite("~p", [ list_to_tuple(generate_Nums(random:uniform(10)))]);
		_ -> io:fwrite("~p", [generate_Nums(random:uniform(10))])
		end. 

% generate_Args() -> 
%	Variables = ["X","Y","Z","M","N","O","P","Q","R","S","T"].

generate_Nums(0) -> [];
generate_Nums(N) -> [random:uniform(1000)|generate_Nums(N-1)].

%% This method generates a Simple list comprehension (only one var).

generate_SIMPLE() ->
	{OP, NUM} = generate_compOps(),
	io:fwrite("~s~s~p~s~p~s", [ "[ X ", OP , NUM, "|| X <- ", generate_Nums(random:uniform(10)), ", "]) , 
	generate_Comparation("X", random:uniform(1000)),
	io:fwrite ("~s", ["]" ]).

generate_compOps() -> 
	Operators = ["+" ,"*", "-", " div ", " rem "],
	{lists:nth(random:uniform(length(Operators)),Operators), random:uniform(80)}.

%% Generates a very basic function, only one variable.
%% TODO: Expand it for more variables.

%% PROBLEMA: Se puede quedar en un bucle infinito. 

generate_fun() -> generate_fun(random:uniform(7)).

generate_fun(0) -> io:fwrite("~s", ["myfun(_) -> false."]);
generate_fun(N) ->
io:fwrite( "~s",["myfun(X) when "]),
generate_Comparation("X", random:uniform(100)),
case random:uniform(2) of 
	1 -> io:fwrite("~s", [lists:nth(random:uniform(5),[" and ", " or ", " andalso ", " orelse ", " xor ", " not "])]),
	generate_Comparation("X", random:uniform(100));
	_ -> []
	end,
 case random:uniform(5) of		  
 1 -> io:fwrite("~s~p" ,[" -> ", random:uniform(100)]);
 2 -> io:fwrite("~s~s" ,[" -> X ",lists:nth(random:uniform(4),[" + " ," * ", " - ", " / "])]), generate();
 _ -> io:fwrite("~s", [ " -> myfun(" ]),
 case random:uniform(2) of 1 -> io:fwrite("~s~s",[" X ",lists:nth(random:uniform(4),[" + " ," * ", " - ", " / "])]);
 	_ -> [] end,
  generate(), io:fwrite("~s",[")"])
end,
io:fwrite("~s",["; "]),
generate_fun(N-1).

