-module(randerl).
-export([main/1]).

-define(ARITH_OPS, ["+", "*", "-", "/"]).
-define(BOOL_OPS,  [" and ", " or ", " andalso ", " orelse ", " xor "]).
-define(COMP_OPS,  ["=:=", "=/=", "==", "/=", ">=", "=<", ">", "<"]).
-define(FUN_NAMES, ["foo", "bar", "qux", "foobar", "fooqux"]).

%% Outputs a simple random program. 
main(Desired_Name) ->
    {ok,PF0} = file:open("randprog_"++Desired_Name++"_o0.erl",  write),
    {ok,PF1} = file:open("randprog_"++Desired_Name++"_o1.erl",  write),
    {ok,PF2} = file:open("randprog_"++Desired_Name++"_o2.erl",  write),
    {ok,PF3} = file:open("randprog_"++Desired_Name++"_o3.erl",  write),
    {ok,PF4} = file:open("randprog_"++Desired_Name++"_beam.erl",write),
    S0=io_lib:format("~s~s~s",["-module(randprog_",Desired_Name,"_o0).   \n-export([main/4]). \n"]),
    S1=io_lib:format("~s~s~s",["-module(randprog_",Desired_Name,"_o1).   \n-export([main/4]). \n"]),
    S2=io_lib:format("~s~s~s",["-module(randprog_",Desired_Name,"_o2).   \n-export([main/4]). \n"]),
    S3=io_lib:format("~s~s~s",["-module(randprog_",Desired_Name,"_o3).   \n-export([main/4]). \n"]),
    S4=io_lib:format("~s~s~s",["-module(randprog_",Desired_Name,"_beam). \n-export([main/4]). \n"]),
    % io:put_chars(PF,S),
    % file:close(PF),
    Fun_List = [{F,random:uniform(3)} || F <- ?FUN_NAMES],
    Funs = lists:sublist(Fun_List, random:uniform(5)),
    Xs=io_lib:format("~s",["main(X,Y,Z,Q) -> "] ),
    Xxs = complete_Main(Funs),
    Xxxs = do_FUNS(Funs, Funs),
    io:put_chars(PF0,S0++Xs++Xxs++Xxxs),
    io:put_chars(PF1,S1++Xs++Xxs++Xxxs),
    io:put_chars(PF2,S2++Xs++Xxs++Xxxs),
    io:put_chars(PF3,S3++Xs++Xxs++Xxxs),
    io:put_chars(PF4,S4++Xs++Xxs++Xxxs),
    file:close(PF0),
    file:close(PF1),
    file:close(PF2),
    file:close(PF3),
    file:close(PF4).

complete_Main([{Fun,Arity}]) ->
    case Arity of
    1 -> io_lib:format("~s~s~s~s~s~s~s~s",[Fun,"(X) +",Fun,"(Y) - ",Fun,"(Z) *",Fun,"(Q) .\n"]); 
    2 -> io_lib:format("~s~s~s~s~s~s~s~s",[Fun,"(X,Y) /",Fun,"(Y,Z) - ",Fun,"(Q,Q) *",Fun,"(Q,X) .\n"]);
    _ -> io_lib:format("~s~s~s~s~s~s~s~s",[Fun,"(X,Y,Z) -",Fun,"(Y,Y,Z) / ",Fun,"(Z,Q,X) *",Fun,"(X,X,Q) .\n"]) 
    end ;

complete_Main([{Fun,Arity}|Rest_Funs]) ->
    case Arity of
    1 -> io_lib:format("~s~s~s~s~s~s~s~s",[Fun,"(X) +",Fun,"(Y) - ",Fun,"(Z) *",Fun,"(Q) \n -"]); 
    2 -> io_lib:format("~s~s~s~s~s~s~s~s",[Fun,"(X,Y) /",Fun,"(Y,Z) - ",Fun,"(Q,Q) *",Fun,"(Q,X) \n +"]); 
    _ -> io_lib:format("~s~s~s~s~s~s~s~s",[Fun,"(X,Y,Z) -",Fun,"(Y,Y,Z) / ",Fun,"(Z,Q,X) *",Fun,"(X,X,Q) \n /"]) 
    end ++ 
    complete_Main(Rest_Funs).


do_FUNS([], _) ->
    io_lib:format("~s", ["\n\n"]);
do_FUNS([{Fun,Arity}|Rest], Funs) -> 
    Fun_Args = lists:sublist(["X","Y","Z"], Arity),
    io_lib:format("~s~s", [Fun,"("]) ++
    display_args(Fun_Args) ++
    io_lib:format("~s", [") when "]) ++
    first_Cond(lists:sublist(Fun_Args, random:uniform(Arity))) ++
    fun_loop(Fun, Fun_Args, random:uniform(6), Funs) ++
    do_FUNS(Rest, Funs).

first_Cond([Var]) -> 
    io_lib:format("~s~s~s~p~s",["(",Var, " =< 0) ->", num(), ";\n"]); 
first_Cond([FirstVar|Rest]) -> 
    io_lib:format("~s~s~s",["(",FirstVar, " =< 0) or"]) ++ 
    first_Cond(Rest).

fun_loop(Fun,Vars,0,_) -> 
    io_lib:format("~s~s",[Fun,"("]) ++
    display_args(Vars) ++
    io_lib:format("~s~p~s",[") -> ",num(),".\n\n"]);
fun_loop(Fun,Vars,Times,Funs) ->
    Temp_Args = lists:sublist(["P","Q","R","S"],random:uniform(4)),
    io_lib:format("~s~s",[Fun,"("]) ++
    display_args(Vars) ++
    io_lib:format("~s",[") when "]) ++ 
    genComps(random:uniform(2),Vars) ++
    io_lib:format("~s",[" -> \n"]) ++
    vars_Declaration(Temp_Args,Funs++Vars) ++
    io_lib:format("~s", ["A = trunc("]) ++
    display_args([hd(Temp_Args)]) ++
    io_lib:format("~s",[") div (round("]) ++
    display_args([hd(lists:reverse(Temp_Args))]) ++ 
    io_lib:format("~s~p~s~p~s~p~s~p~s",[")+", random:uniform(100),") +", random:uniform(100), ",\nB = A rem ", random:uniform(100), "+",num(),",\n"]) ++
    random_operations(Vars++["A","B"], ?ARITH_OPS) ++
    io_lib:format("~s~p~s",[" + ",num()," ;\n\n"]) ++
    fun_loop(Fun,Vars,Times-1,Funs).

display_args([Elem]) -> 	
    case discover_type(Elem) of
	int -> io_lib:format("~p", [Elem]);
	flo -> io_lib:format("~f", [Elem]);
	str -> io_lib:format("~s", [Elem])
    end;
display_args([HList|TList]) -> 
    case discover_type(HList) of
	int -> io_lib:format("~p~s", [HList,","]);
	flo -> io_lib:format("~f~s", [HList,","]);
	str -> io_lib:format("~s~s", [HList,","])
    end 
    ++ display_args(TList).

%% Returns the type of the variable X.
discover_type(X) when is_integer(X) -> int;
discover_type(X) when is_float(X) -> flo;
discover_type(_) -> str.

%% Generates random comparisons. 
genComps(1, Vars) ->
    Comparator = lists:nth(random:uniform(8), ?COMP_OPS),
    Not = lists:nth(random:uniform(2), [" not ", ""]),
    Var1 = case random:uniform(3) of
    1 -> io_lib:format("~p", [num()]);
    _ -> io_lib:format("~s", [lists:nth(random:uniform(length(Vars)),Vars)])
    end,
    Var2 = case random:uniform(3) of
    1 -> io_lib:format("~p", [num()]);
    _ -> io_lib:format("~s", [lists:nth(random:uniform(length(Vars)),Vars)])
    end ,
    io_lib:format("~s~s", [Not,"("]) ++
    Var1 ++
    io_lib:format("~s", [Comparator]) ++
    Var2 ++
    io_lib:format("~s", [") "]);
genComps(N,Vars) -> 
    Comparator = lists:nth(random:uniform(8), ?COMP_OPS),
    Not     = lists:nth(random:uniform(2), [" not ", ""]),
    Logical = lists:nth(random:uniform(5), ?BOOL_OPS),
    Var1= case random:uniform(3) of
    1 -> io_lib:format("~p",[num()]);
    _ -> io_lib:format("~s",[lists:nth(random:uniform(length(Vars)),Vars)])
    end ,
    Var2 = case random:uniform(2) of
    1 -> io_lib:format("~p",[num()]);
    _ -> io_lib:format("~s",[lists:nth(random:uniform(length(Vars)),Vars)])
    end,
    io_lib:format("~s~s", [ Not,"("]) ++
    Var1++
    io_lib:format("~s",[Comparator]) ++
    Var2++
    io_lib:format("~s~s",[") ",Logical]) ++
    genComps(N-1,Vars).

recurs_decr(1,Possibilities) ->
    display_args([lists:nth(random:uniform(length(Possibilities)),Possibilities)]) ++
    io_lib:format("~s~p",["-", num()]);
recurs_decr(N_Args,Possibilities) ->
    display_args([lists:nth(random:uniform(length(Possibilities)),Possibilities)]) ++
    io_lib:format("~s~p~s",["-", num(),", "]) ++
    recurs_decr(N_Args-1,Possibilities).

op_Loops(1,Possibilities) ->
    Tuples = [T || T <- Possibilities, is_tuple(T)],
    Vars = Possibilities -- Tuples,
    Elem = lists:nth(random:uniform(length(Vars)),Vars),
    {Fun,Arity} = lists:nth(random:uniform(length(Tuples)),Tuples),
    case random:uniform(3) of
	1 -> io_lib:format("~s~s",[Fun,"("]) ++
	     recurs_decr(Arity,Vars) ++
	     io_lib:format("~s",	[ ") "]);
	2 -> io_lib:format("~s",[Elem]);
	_ -> io_lib:format("~p",[num()])
    end;
op_Loops(N,Possibilities) -> 
    Operator = lists:nth(random:uniform(4), ?ARITH_OPS), 
    Tuples = [T || T <- Possibilities, is_tuple(T)],
    Vars = Possibilities -- Tuples,
    Elem = lists:nth(random:uniform(length(Vars)),Vars),
    {Fun,Arity} = lists:nth(random:uniform(length(Tuples)),Tuples),
    case random:uniform(3) of
	1 -> io_lib:format("~s~s",[Fun,"( "]) ++
	     recurs_decr(Arity,Vars) ++
	     io_lib:format("~s",[ ") "]);
	2 -> io_lib:format("~s",[ Elem ]);
	_ -> io_lib:format("~p",[num()])
    end ++
    io_lib:format("~s",[Operator]) ++
    op_Loops(N-1,Possibilities).

vars_Declaration([], _) -> 
    io_lib:format("~s", [""]);
vars_Declaration([Var|Rest], Possibilities) -> 
    io_lib:format("~s~s", [Var," = "]) ++
    op_Loops(random:uniform(5), Possibilities) ++
    io_lib:format("~s", [", \n"]) ++
    vars_Declaration(Rest, [Var|Possibilities]).

random_operations([Var],_) ->
    io_lib:format("~s", [Var]);
random_operations([Var|Rest],Operators) -> 
    io_lib:format("~s~s",[Var,lists:nth(random:uniform(4),Operators)]) ++
    random_operations(Rest,Operators).

num() ->
    case random:uniform(10) of
	1 -> random:uniform(30);
	2 -> random:uniform(500);
	3 -> random:uniform(10000);
	4 -> random:uniform();
    5 -> random:uniform(10) + random:uniform();
    6 -> random:uniform(100) + random:uniform();
    7 -> random:uniform(1000) + random:uniform();
    _ -> random:uniform(100000) + random:uniform()
    end.


%% - UNUSED STUFF - %%
% generate_Comparison(X,Y) ->
%     Chosen_One = lists:nth(random:uniform(length(?COMP_OPS)), ?COMP_OPS),
%     io_lib:format("~s", ["("]),
%     case discover_type(X) of
% 	int -> io_lib:format("~p ",[X]);
% 	f -> io_lib:format("~f ", [X]);
% 	_ -> io_lib:format("~s ",[X])
%     end,
%     io_lib:format("~s ", [Chosen_One]),
%     case discover_type(Y) of
% 	int -> io_lib:format("~p ",[Y]);
% 	f -> io_lib:format("~f ", [Y]);
% 	_ -> io_lib:format("~s ",[Y])
%     end,
%     io_lib:format("~s", [")"]).

% generate_Nums(0) -> [];
% generate_Nums(N) -> [num()|generate_Nums(N-1)].

% generate_listComprehension() ->
%     {OP, NUM} = generate_compOps(),
%     io_lib:format("~s~s~p~s~p~s", [ " List = [ Q ", OP , NUM, "|| Q <- ", generate_Nums(random:uniform(10)), ", "]), 
%     generate_Comparison("Q", random:uniform(1000)),
%     io_lib:format ("~s", ["]" ]).

% generate_compOps() -> 
%     {lists:nth(random:uniform(length(?ARITH_OPS)),?ARITH_OPS), random:uniform(1000)}.

